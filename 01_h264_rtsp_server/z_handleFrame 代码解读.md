
# 看看人家的位运算
>  rtpHeader->payload[0] = (naluType & 0x60) | 28;
* 它负责构造分片单元(FU)的指示字节(FU Indicator)。

### 代码解析

```c++
rtpHeader->payload[0] = (naluType & 0x60) | 28;
```
### 背景知识
   * 在H264的RTP传输中，当NALU（网络抽象层单元）过大时，需要分片传输。这时会用到FU-A分片模式，
   * 每个分片包有两个额外头部：
     * FU Indicator (1字节)
     * FU Header (1字节)

   * 这行代码就是在构造FU Indicator。

###   NALU头部结构
   原始H264 NALU的第一个字节结构：

```c
+---------------+
|F|NRI|  Type   |
+---------------+
```
  * F (1bit)：禁止位，通常为0
  * NRI (2bits)：重要性指示（值越大越重要）
  * Type (5bits)：NALU类型（如7=SPS，8=PPS，5=IDR帧等）

###  代码分解
   > naluType & 0x60：
   * 十六进制0x60 = 二进制01100000，这个掩码会提取出NALU头中的F和NRI位（即保留高3位，清除低5位）

   > | 28：
   * 十进制28 = 二进制00011100，这是FU-A分片的类型号。按位或操作将分片类型与保留的F/NRI位合并

###   结果示例
   * 假设原始NALU头是0x67（SPS帧）：

     * 二进制：01100111
     * 0x67 & 0x60 → 01100000（保留了F和NRI）
     * 01100000 | 00011100 → 01111100（最终FU Indicator）

###  为什么是28？
   * 根据RFC6184标准：
   * 24-31是保留给分片使用的类型值
   * 28(0x1C) 专门表示FU-A分片模式

###  可视化结构
   最终构造的FU Indicator字节：

```c
+---------------+---------------+
|F|NRI|  Type=28 (FU-A)        |
+---------------+---------------+
```
*（高3位来自原NALU，低5位固定为28）

### 后续处理
   * 下一个字节（payload[1]）将是FU Header，包含：
     * S/E/R标志位（标记分片的开始/结束）
     * 原始NALU的类型（通过naluType & 0x1F获取）

> 这种设计既保留了原始NALU的重要性信息（NRI），又明确指示了分片传输模式，完全符合H264的RTP传输标准。
---
